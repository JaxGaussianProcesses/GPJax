{"project": "gpjax", "project_url": "https://jaxgaussianprocesses.com/", "show_commit_url": "https://github.com/jaxgaussianprocesses/gpjax/commit/main", "hash_length": 8, "revision_to_hash": {"75": "c091f7d089d356704b4af70cb8f1ffa5febea318", "85": "37d5944f7f6a6f06d37939b20ba5210e6365c271", "135": "24fbde8548c6c56fc0324c3d1bdbd631975615a3", "136": "acf7d2fae06ac646a1d82aceac873cb903b3cad8", "219": "19dbc743307c4e65cb79caa6d569efd7d238a1cf", "380": "4d3e0b4eaed77357c31d8a9fde248833e1ae976a", "472": "b0bbe49e8afbb4e069d0b908a25f454a8334b3d3", "498": "3374e5199811ae4bf8d63c19fb7900d8e1b8d38b", "526": "b1142ab02ac226a58977a51b1b6b9a371b85dfff", "550": "2f00b111164cf12d24913785dda05e3c37f097f4", "556": "657a41620fbccb86ac9073f27ceff330d3ae2ee9", "572": "8ac2427deee5d451dfc0decd5456e8ec80b2a610", "760": "fb24af8b80540ec95f83ce77bdde49aac0438137", "783": "61434b6282c3cae91722893908ed343b4f0da74e", "796": "f681d71a77c5627144e2519438a731bb42f1734e", "811": "c50d34d44977e3ef2290576ee1e9b82a69656431", "819": "e832e6ad77a44399df291ef4896e250f2ea51894", "838": "696ed9d43e3fa948af9224ddefa6b2b478a0554d", "885": "c0809b4197d60af447d33ab5d740178bde169ba2", "888": "0bd609dcd8a939da5d457d52bca3d74a619cd9c8", "891": "7527a57c55b540f574d0671f5f6355312daf3e69", "999": "d50be701c9f489e4b737fc03e2634151dc0f7615", "1012": "38aebe6e6bd5c10275b953b26ecd33157cfe59ac", "1100": "558e797325b5e10448cadda7feea2e71e00e2887", "1124": "6408c68beec68f0f6839d27c111c311a10e11228", "1139": "6f7db6d4adf0011eec0742926f89b80094076ae7", "1153": "c82d10ab7d52f9cd52e699d6924d932a4f13195b", "1155": "02b58809fbf74a64ace2172e0b365765de615a58", "1202": "e98050e6300b0732718d095b2c797a251ff22edd", "1254": "77aa81caba8134332b1696474e628802bcbd6fcf"}, "revision_to_date": {"75": 1610053917000, "85": 1610355065000, "135": 1614762019000, "136": 1614763238000, "219": 1644266353000, "380": 1653496033000, "472": 1656952299000, "498": 1658482532000, "526": 1660205877000, "550": 1661202118000, "556": 1661247762000, "572": 1662620605000, "760": 1667851403000, "783": 1668780973000, "796": 1669751638000, "811": 1670968906000, "819": 1671390625000, "838": 1671742015000, "885": 1673255398000, "888": 1673258397000, "891": 1674172066000, "999": 1683840808000, "1012": 1683842430000, "1100": 1685476401000, "1124": 1686167284000, "1139": 1686590161000, "1153": 1686771544000, "1155": 1686773031000, "1202": 1687604114000, "1254": 1691475342000}, "params": {"branch": ["main", "benchmarking"]}, "graph_param_list": [], "benchmarks": {"kernels.ArcCosine.time_covfunc_call": {"code": "class ArcCosine:\n    def time_covfunc_call(self, n_datapoints, n_dims):\n        self.kernel.gram(self.X)\n\n    def setup(self, n_datapoints, n_dims):\n        super().setup(n_datapoints, n_dims)\n        self.kernel = kernels.ArcCosine(active_dims=list(range(n_dims)))", "min_run_count": 2, "name": "kernels.ArcCosine.time_covfunc_call", "number": 0, "param_names": ["n_data", "dimensionality"], "params": [["10", "100", "500", "1000", "2000"], ["1", "2", "5"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "f923a5feb1913469c66f702d89993918b418cc376b993df1cb7b974c3af01dfe", "warmup_time": -1}, "kernels.Linear.time_covfunc_call": {"code": "class Linear:\n    def time_covfunc_call(self, n_datapoints, n_dims):\n        self.kernel.gram(self.X)\n\n    def setup(self, n_datapoints, n_dims):\n        super().setup(n_datapoints, n_dims)\n        self.kernel = kernels.Linear(active_dims=list(range(n_dims)))", "min_run_count": 2, "name": "kernels.Linear.time_covfunc_call", "number": 0, "param_names": ["n_data", "dimensionality"], "params": [["10", "100", "500", "1000", "2000"], ["1", "2", "5"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "937688fe2a0aa44886c8c5856202502b9c82d2043d1034bf1c5984d73999b6b3", "warmup_time": -1}, "kernels.Matern12.time_covfunc_call": {"code": "class Matern12:\n    def time_covfunc_call(self, n_datapoints, n_dims):\n        self.kernel.gram(self.X)\n\n    def setup(self, n_datapoints, n_dims):\n        super().setup(n_datapoints, n_dims)\n        self.kernel = kernels.Matern12(active_dims=list(range(n_dims)))", "min_run_count": 2, "name": "kernels.Matern12.time_covfunc_call", "number": 0, "param_names": ["n_data", "dimensionality"], "params": [["10", "100", "500", "1000", "2000"], ["1", "2", "5"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "847a1c25403643211b2dbe93ac755ad2ddcd5da5e2b53136841d6ab99cc12699", "warmup_time": -1}, "kernels.Matern32.time_covfunc_call": {"code": "class Matern32:\n    def time_covfunc_call(self, n_datapoints, n_dims):\n        self.kernel.gram(self.X)\n\n    def setup(self, n_datapoints, n_dims):\n        super().setup(n_datapoints, n_dims)\n        self.kernel = kernels.Matern32(active_dims=list(range(n_dims)))", "min_run_count": 2, "name": "kernels.Matern32.time_covfunc_call", "number": 0, "param_names": ["n_data", "dimensionality"], "params": [["10", "100", "500", "1000", "2000"], ["1", "2", "5"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "a520e46707f3b3181f63c1e1a372e9e6cea4d8bcfc1d24ab4b7f40ff1dadf171", "warmup_time": -1}, "kernels.Matern52.time_covfunc_call": {"code": "class Matern52:\n    def time_covfunc_call(self, n_datapoints, n_dims):\n        self.kernel.gram(self.X)\n\n    def setup(self, n_datapoints, n_dims):\n        super().setup(n_datapoints, n_dims)\n        self.kernel = kernels.Matern52(active_dims=list(range(n_dims)))", "min_run_count": 2, "name": "kernels.Matern52.time_covfunc_call", "number": 0, "param_names": ["n_data", "dimensionality"], "params": [["10", "100", "500", "1000", "2000"], ["1", "2", "5"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "179838852e999abcac68e90c141724342d0b4a25656f5ea7be6409ac9205b91f", "warmup_time": -1}, "kernels.Polynomial.time_covfunc_call": {"code": "class Polynomial:\n    def time_covfunc_call(self, n_datapoints, n_dims):\n        self.kernel.gram(self.X)\n\n    def setup(self, n_datapoints, n_dims):\n        super().setup(n_datapoints, n_dims)\n        self.kernel = kernels.Polynomial(active_dims=list(range(n_dims)))", "min_run_count": 2, "name": "kernels.Polynomial.time_covfunc_call", "number": 0, "param_names": ["n_data", "dimensionality"], "params": [["10", "100", "500", "1000", "2000"], ["1", "2", "5"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "67213fe983f9f09d6213609250aab0870f9b652c1fb08e07f68581af193365d5", "warmup_time": -1}, "kernels.PoweredExponential.time_covfunc_call": {"code": "class PoweredExponential:\n    def time_covfunc_call(self, n_datapoints, n_dims):\n        self.kernel.gram(self.X)\n\n    def setup(self, n_datapoints, n_dims):\n        super().setup(n_datapoints, n_dims)\n        self.kernel = kernels.PoweredExponential(active_dims=list(range(n_dims)))", "min_run_count": 2, "name": "kernels.PoweredExponential.time_covfunc_call", "number": 0, "param_names": ["n_data", "dimensionality"], "params": [["10", "100", "500", "1000", "2000"], ["1", "2", "5"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "2da6e3291d5e431eed969aaba40c4b42f226ebad022e3ea56b257ab2e2e97bb4", "warmup_time": -1}, "kernels.RBF.time_covfunc_call": {"code": "class RBF:\n    def time_covfunc_call(self, n_datapoints, n_dims):\n        self.kernel.gram(self.X)\n\n    def setup(self, n_datapoints, n_dims):\n        super().setup(n_datapoints, n_dims)\n        self.kernel = kernels.RBF(active_dims=list(range(n_dims)))", "min_run_count": 2, "name": "kernels.RBF.time_covfunc_call", "number": 0, "param_names": ["n_data", "dimensionality"], "params": [["10", "100", "500", "1000", "2000"], ["1", "2", "5"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "b52f5ad2fdad31ce7060e8eb015e77504de6b2566db3b05e702d48e17f7c3e7f", "warmup_time": -1}, "kernels.RationalQuadratic.time_covfunc_call": {"code": "class RationalQuadratic:\n    def time_covfunc_call(self, n_datapoints, n_dims):\n        self.kernel.gram(self.X)\n\n    def setup(self, n_datapoints, n_dims):\n        super().setup(n_datapoints, n_dims)\n        self.kernel = kernels.RationalQuadratic(active_dims=list(range(n_dims)))", "min_run_count": 2, "name": "kernels.RationalQuadratic.time_covfunc_call", "number": 0, "param_names": ["n_data", "dimensionality"], "params": [["10", "100", "500", "1000", "2000"], ["1", "2", "5"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "4ff62cadc9b2f84aa5f6ea06736910da029bd98f3f7191de57356b43d6915b42", "warmup_time": -1}, "linops.LinOps.time_inverse": {"code": "class LinOps:\n    def time_inverse(self, n_datapoints):\n        self.linop.inverse()\n\n    def setup(self, n_datapoints):\n        key = jr.PRNGKey(123)\n        self.X = jnp.asarray(make_spd_matrix(n_dim=n_datapoints, random_state=123))\n        self.y = jr.normal(key=key, shape=(n_datapoints, 1))\n        self.linop = DenseLinearOperator(matrix=self.X)", "min_run_count": 2, "name": "linops.LinOps.time_inverse", "number": 0, "param_names": ["n_data"], "params": [["10", "100", "200", "500", "1000"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "823cf69fc1b04db01ca405df4e4ad858be5f2f961474f37024055ee6b184b59d", "warmup_time": -1}, "linops.LinOps.time_logdet": {"code": "class LinOps:\n    def time_logdet(self, n_datapoints):\n        self.linop.log_det()\n\n    def setup(self, n_datapoints):\n        key = jr.PRNGKey(123)\n        self.X = jnp.asarray(make_spd_matrix(n_dim=n_datapoints, random_state=123))\n        self.y = jr.normal(key=key, shape=(n_datapoints, 1))\n        self.linop = DenseLinearOperator(matrix=self.X)", "min_run_count": 2, "name": "linops.LinOps.time_logdet", "number": 0, "param_names": ["n_data"], "params": [["10", "100", "200", "500", "1000"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "639dad2164ac90fc52cdc42feb86a3a123ad523816883172d84302c4b5b0cdb9", "warmup_time": -1}, "linops.LinOps.time_root": {"code": "class LinOps:\n    def time_root(self, n_datapoints):\n        self.linop.to_root()\n\n    def setup(self, n_datapoints):\n        key = jr.PRNGKey(123)\n        self.X = jnp.asarray(make_spd_matrix(n_dim=n_datapoints, random_state=123))\n        self.y = jr.normal(key=key, shape=(n_datapoints, 1))\n        self.linop = DenseLinearOperator(matrix=self.X)", "min_run_count": 2, "name": "linops.LinOps.time_root", "number": 0, "param_names": ["n_data"], "params": [["10", "100", "200", "500", "1000"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "cae06127f9dd4abd0e43b5d56de47907b15a7914dec0001a3dc0bf8e6ede3443", "warmup_time": -1}, "linops.LinOps.time_solve": {"code": "class LinOps:\n    def time_solve(self, n_datapoints):\n        self.linop.solve(self.y)\n\n    def setup(self, n_datapoints):\n        key = jr.PRNGKey(123)\n        self.X = jnp.asarray(make_spd_matrix(n_dim=n_datapoints, random_state=123))\n        self.y = jr.normal(key=key, shape=(n_datapoints, 1))\n        self.linop = DenseLinearOperator(matrix=self.X)", "min_run_count": 2, "name": "linops.LinOps.time_solve", "number": 0, "param_names": ["n_data"], "params": [["10", "100", "200", "500", "1000"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "ae85c8782ac7af301f71850798f51a6e935da6685811c777f97ab715bbdb0ebc", "warmup_time": -1}, "objectives.Bernoulli.time_eval": {"code": "class Bernoulli:\n    def time_eval(self, n_datapoints, n_dims):\n        self.objective.step(self.posterior, self.data).block_until_ready()\n\n    def setup(self, n_datapoints, n_dims):\n        key = jr.PRNGKey(123)\n        self.X = jr.normal(key=key, shape=(n_datapoints, n_dims))\n        self.y = jnp.where(jnp.sin(self.X[:, :1]) > 0, 1, 0)\n        self.data = gpx.Dataset(X=self.X, y=self.y)\n        kernel = gpx.kernels.RBF(active_dims=list(range(n_dims)))\n        meanf = gpx.mean_functions.Constant()\n        self.prior = gpx.Prior(kernel=kernel, mean_function=meanf)\n        self.likelihood = gpx.likelihoods.Bernoulli(num_datapoints=self.data.n)\n        self.objective = gpx.LogPosteriorDensity()\n        self.posterior = self.prior * self.likelihood", "min_run_count": 2, "name": "objectives.Bernoulli.time_eval", "number": 0, "param_names": ["n_data", "n_dims"], "params": [["10", "100", "200", "500", "1000"], ["1", "2", "5"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "fb5ee5905aa83614349ecf957e77246930a4577b1b4308bb1fd4961104de464f", "warmup_time": -1}, "objectives.Bernoulli.time_grad": {"code": "class Bernoulli:\n    def time_grad(self, n_datapoints, n_dims):\n        jax.block_until_ready(jax.grad(self.objective.step)(self.posterior, self.data))\n\n    def setup(self, n_datapoints, n_dims):\n        key = jr.PRNGKey(123)\n        self.X = jr.normal(key=key, shape=(n_datapoints, n_dims))\n        self.y = jnp.where(jnp.sin(self.X[:, :1]) > 0, 1, 0)\n        self.data = gpx.Dataset(X=self.X, y=self.y)\n        kernel = gpx.kernels.RBF(active_dims=list(range(n_dims)))\n        meanf = gpx.mean_functions.Constant()\n        self.prior = gpx.Prior(kernel=kernel, mean_function=meanf)\n        self.likelihood = gpx.likelihoods.Bernoulli(num_datapoints=self.data.n)\n        self.objective = gpx.LogPosteriorDensity()\n        self.posterior = self.prior * self.likelihood", "min_run_count": 2, "name": "objectives.Bernoulli.time_grad", "number": 0, "param_names": ["n_data", "n_dims"], "params": [["10", "100", "200", "500", "1000"], ["1", "2", "5"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "38185efea870c669bb43effcdeb9736469e16211eb9bf1c385ef6e9e7016af9d", "warmup_time": -1}, "objectives.Gaussian.time_eval": {"code": "class Gaussian:\n    def time_eval(self, n_datapoints, n_dims):\n        self.objective.step(self.posterior, self.data).block_until_ready()\n\n    def setup(self, n_datapoints, n_dims):\n        key = jr.PRNGKey(123)\n        self.X = jr.normal(key=key, shape=(n_datapoints, n_dims))\n        self.y = jnp.sin(self.X[:, :1])\n        self.data = gpx.Dataset(X=self.X, y=self.y)\n        kernel = gpx.kernels.RBF(active_dims=list(range(n_dims)))\n        meanf = gpx.mean_functions.Constant()\n        self.prior = gpx.Prior(kernel=kernel, mean_function=meanf)\n        self.likelihood = gpx.likelihoods.Gaussian(num_datapoints=self.data.n)\n        self.objective = gpx.ConjugateMLL()\n        self.posterior = self.prior * self.likelihood", "min_run_count": 2, "name": "objectives.Gaussian.time_eval", "number": 0, "param_names": ["n_data", "n_dims"], "params": [["10", "100", "200", "500", "1000"], ["1", "2", "5"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "c95ff081d05fd04891867ccd92dd38fc091c1617f991faf7708322edd5763b26", "warmup_time": -1}, "objectives.Gaussian.time_grad": {"code": "class Gaussian:\n    def time_grad(self, n_datapoints, n_dims):\n        jax.block_until_ready(jax.grad(self.objective.step)(self.posterior, self.data))\n\n    def setup(self, n_datapoints, n_dims):\n        key = jr.PRNGKey(123)\n        self.X = jr.normal(key=key, shape=(n_datapoints, n_dims))\n        self.y = jnp.sin(self.X[:, :1])\n        self.data = gpx.Dataset(X=self.X, y=self.y)\n        kernel = gpx.kernels.RBF(active_dims=list(range(n_dims)))\n        meanf = gpx.mean_functions.Constant()\n        self.prior = gpx.Prior(kernel=kernel, mean_function=meanf)\n        self.likelihood = gpx.likelihoods.Gaussian(num_datapoints=self.data.n)\n        self.objective = gpx.ConjugateMLL()\n        self.posterior = self.prior * self.likelihood", "min_run_count": 2, "name": "objectives.Gaussian.time_grad", "number": 0, "param_names": ["n_data", "n_dims"], "params": [["10", "100", "200", "500", "1000"], ["1", "2", "5"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "17f8bbfec9594b825cce2619ff9cdff44460a0f3b9273276e132c466903cad5d", "warmup_time": -1}, "objectives.Poisson.time_eval": {"code": "class Poisson:\n    def time_eval(self, n_datapoints, n_dims):\n        self.objective.step(self.posterior, self.data).block_until_ready()\n\n    def setup(self, n_datapoints, n_dims):\n        key = jr.PRNGKey(123)\n        self.X = jr.normal(key=key, shape=(n_datapoints, n_dims))\n        f = lambda x: 2.0 * jnp.sin(3 * x) + 0.5 * x  # latent function\n        self.y = jr.poisson(key, jnp.exp(f(self.X)))\n        self.data = gpx.Dataset(X=self.X, y=self.y)\n        kernel = gpx.kernels.RBF(active_dims=list(range(n_dims)))\n        meanf = gpx.mean_functions.Constant()\n        self.prior = gpx.Prior(kernel=kernel, mean_function=meanf)\n        self.likelihood = gpx.likelihoods.Poisson(num_datapoints=self.data.n)\n        self.objective = gpx.LogPosteriorDensity()\n        self.posterior = self.prior * self.likelihood", "min_run_count": 2, "name": "objectives.Poisson.time_eval", "number": 0, "param_names": ["n_data", "n_dims"], "params": [["10", "100", "200", "500", "1000"], ["1", "2", "5"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "c6980ed01dfd22897a43064bc3210aa38052a9a542e380652f67e7a93e575ce6", "warmup_time": -1}, "objectives.Poisson.time_grad": {"code": "class Poisson:\n    def time_grad(self, n_datapoints, n_dims):\n        jax.block_until_ready(jax.grad(self.objective.step)(self.posterior, self.data))\n\n    def setup(self, n_datapoints, n_dims):\n        key = jr.PRNGKey(123)\n        self.X = jr.normal(key=key, shape=(n_datapoints, n_dims))\n        f = lambda x: 2.0 * jnp.sin(3 * x) + 0.5 * x  # latent function\n        self.y = jr.poisson(key, jnp.exp(f(self.X)))\n        self.data = gpx.Dataset(X=self.X, y=self.y)\n        kernel = gpx.kernels.RBF(active_dims=list(range(n_dims)))\n        meanf = gpx.mean_functions.Constant()\n        self.prior = gpx.Prior(kernel=kernel, mean_function=meanf)\n        self.likelihood = gpx.likelihoods.Poisson(num_datapoints=self.data.n)\n        self.objective = gpx.LogPosteriorDensity()\n        self.posterior = self.prior * self.likelihood", "min_run_count": 2, "name": "objectives.Poisson.time_grad", "number": 0, "param_names": ["n_data", "n_dims"], "params": [["10", "100", "200", "500", "1000"], ["1", "2", "5"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "9da29fc2c40db47e799a629b998835c42f1188786ec4cb956931def49fe94db7", "warmup_time": -1}, "predictions.Bernoulli.time_predict": {"code": "class Bernoulli:\n    def time_predict(self, n_test, n_dims):\n        self.posterior.predict(test_inputs=self.xtest, train_data=self.data)\n\n    def setup(self, n_test, n_dims):\n        key = jr.PRNGKey(123)\n        self.X = jr.normal(key=key, shape=(100, n_dims))\n        self.y = jnp.sin(self.X[:, :1])\n        self.y = jnp.where(self.y > 0, 1, 0)\n        self.data = gpx.Dataset(X=self.X, y=self.y)\n        kernel = gpx.kernels.RBF(active_dims=list(range(n_dims)))\n        meanf = gpx.mean_functions.Constant()\n        self.prior = gpx.Prior(kernel=kernel, mean_function=meanf)\n        self.likelihood = gpx.likelihoods.Bernoulli(num_datapoints=self.data.n)\n        self.posterior: ConjugatePosterior = self.prior * self.likelihood\n        key, subkey = jr.split(key)\n        self.xtest = jr.normal(key=subkey, shape=(n_test, n_dims))", "min_run_count": 2, "name": "predictions.Bernoulli.time_predict", "number": 0, "param_names": ["n_test", "n_dims"], "params": [["100", "200", "500", "1000", "2000", "3000"], ["1", "2", "5"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "857bb8965761478deabc31a9c7d8c448e15b04040ad3000f3215ecfc25b6572a", "warmup_time": -1}, "predictions.Gaussian.time_predict": {"code": "class Gaussian:\n    def time_predict(self, n_test, n_dims):\n        self.posterior.predict(test_inputs=self.xtest, train_data=self.data)\n\n    def setup(self, n_test, n_dims):\n        key = jr.PRNGKey(123)\n        self.X = jr.normal(key=key, shape=(100, n_dims))\n        self.y = jnp.sin(self.X[:, :1])\n        self.data = gpx.Dataset(X=self.X, y=self.y)\n        kernel = gpx.kernels.RBF(active_dims=list(range(n_dims)))\n        meanf = gpx.mean_functions.Constant()\n        self.prior = gpx.Prior(kernel=kernel, mean_function=meanf)\n        self.likelihood = gpx.likelihoods.Gaussian(num_datapoints=self.data.n)\n        self.posterior: ConjugatePosterior = self.prior * self.likelihood\n        key, subkey = jr.split(key)\n        self.xtest = jr.normal(key=subkey, shape=(n_test, n_dims))", "min_run_count": 2, "name": "predictions.Gaussian.time_predict", "number": 0, "param_names": ["n_test", "n_dims"], "params": [["100", "200", "500", "1000", "2000", "3000"], ["1", "2", "5"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "6f0e388859cf4b193a8b671902fd452e57ea9b7330f9a9226a3c683b9dd79fa1", "warmup_time": -1}, "predictions.Poisson.time_predict": {"code": "class Poisson:\n    def time_predict(self, n_test, n_dims):\n        self.posterior.predict(test_inputs=self.xtest, train_data=self.data)\n\n    def setup(self, n_test, n_dims):\n        key = jr.PRNGKey(123)\n        self.X = jr.normal(key=key, shape=(100, n_dims))\n        f = lambda x: 2.0 * jnp.sin(3 * x) + 0.5 * x  # latent function\n        self.y = jr.poisson(key, jnp.exp(f(self.X)))\n        self.data = gpx.Dataset(X=self.X, y=self.y)\n        kernel = gpx.kernels.RBF(active_dims=list(range(n_dims)))\n        meanf = gpx.mean_functions.Constant()\n        self.prior = gpx.Prior(kernel=kernel, mean_function=meanf)\n        self.likelihood = gpx.likelihoods.Bernoulli(num_datapoints=self.data.n)\n        self.posterior: ConjugatePosterior = self.prior * self.likelihood\n        key, subkey = jr.split(key)\n        self.xtest = jr.normal(key=subkey, shape=(n_test, n_dims))", "min_run_count": 2, "name": "predictions.Poisson.time_predict", "number": 0, "param_names": ["n_test", "n_dims"], "params": [["100", "200", "500", "1000", "2000", "3000"], ["1", "2", "5"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "e551f6f771a828ecf51e53287b7c46c8df0944cdba11bf2b731272bbad6d0128", "warmup_time": -1}, "sparse.Sparse.time_eval": {"code": "class Sparse:\n    def time_eval(self, n_datapoints, n_dims):\n        self.objective(self.q, self.data)\n\n    def setup(self, n_datapoints, n_inducing):\n        key = jr.PRNGKey(123)\n        self.X = jr.normal(key=key, shape=(n_datapoints, 1))\n        self.y = jnp.sin(self.X[:, :1])\n        self.data = gpx.Dataset(X=self.X, y=self.y)\n        kernel = gpx.kernels.RBF(active_dims=list(range(1)))\n        meanf = gpx.mean_functions.Constant()\n        self.prior = gpx.Prior(kernel=kernel, mean_function=meanf)\n        self.likelihood = gpx.likelihoods.Gaussian(num_datapoints=self.data.n)\n        self.posterior = self.prior * self.likelihood\n    \n        Z = jnp.linspace(self.X.min(), self.X.max(), n_inducing).reshape(-1, 1)\n        self.q = gpx.CollapsedVariationalGaussian(\n            posterior=self.posterior, inducing_inputs=Z\n        )\n        self.objective = gpx.CollapsedELBO(negative=True)", "min_run_count": 2, "name": "sparse.Sparse.time_eval", "number": 0, "param_names": ["n_data", "n_inducing"], "params": [["2000", "5000", "10000", "20000"], ["10", "20", "50", "100", "200"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "c42a0cef98e7ce98940fdd14075c567a03ab6e0217008f317c0b2ad4bc48bccb", "warmup_time": -1}, "sparse.Sparse.time_grad": {"code": "class Sparse:\n    def time_grad(self, n_datapoints, n_dims):\n        jax.grad(self.objective)(self.q, self.data)\n\n    def setup(self, n_datapoints, n_inducing):\n        key = jr.PRNGKey(123)\n        self.X = jr.normal(key=key, shape=(n_datapoints, 1))\n        self.y = jnp.sin(self.X[:, :1])\n        self.data = gpx.Dataset(X=self.X, y=self.y)\n        kernel = gpx.kernels.RBF(active_dims=list(range(1)))\n        meanf = gpx.mean_functions.Constant()\n        self.prior = gpx.Prior(kernel=kernel, mean_function=meanf)\n        self.likelihood = gpx.likelihoods.Gaussian(num_datapoints=self.data.n)\n        self.posterior = self.prior * self.likelihood\n    \n        Z = jnp.linspace(self.X.min(), self.X.max(), n_inducing).reshape(-1, 1)\n        self.q = gpx.CollapsedVariationalGaussian(\n            posterior=self.posterior, inducing_inputs=Z\n        )\n        self.objective = gpx.CollapsedELBO(negative=True)", "min_run_count": 2, "name": "sparse.Sparse.time_grad", "number": 0, "param_names": ["n_data", "n_inducing"], "params": [["2000", "5000", "10000", "20000"], ["10", "20", "50", "100", "200"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "5aaf0153a37ed3daf24fa0e2a128884fc50602f21a8cc268d5ddb989aaabcd66", "warmup_time": -1}}, "machines": {"Toms-MacBook-Air-2.local": {"arch": "arm64", "cpu": "Apple M1", "machine": "Toms-MacBook-Air-2.local", "num_cpu": "8", "os": "Darwin 22.3.0", "ram": "8589934592", "version": 1}}, "tags": {"V0.3": 136, "v0.1.1": 75, "v0.2.0": 85, "v0.3": 135, "v0.4": 219, "v0.4.10": 526, "v0.4.11": 550, "v0.4.12": 556, "v0.4.13": 572, "v0.4.6": 380, "v0.4.8": 472, "v0.4.9": 498, "v0.5": 760, "v0.5.1": 783, "v0.5.2": 796, "v0.5.4": 811, "v0.5.5": 819, "v3.0": 135, "v0.5.6": 838, "v0.5.7": 885, "v0.5.8": 888, "v0.5.9": 891, "v0.6": 999, "v0.6.1": 1012, "v0.6.2": 1100, "v0.6.3": 1124, "v0.6.4": 1139, "v0.6.5": 1153, "v0.6.6": 1155, "v0.6.7": 1202, "v0.6.8": 1254}, "pages": [["", "Grid view", "Display as a agrid"], ["summarylist", "List view", "Display as a list"], ["regressions", "Show regressions", "Display information about recent regressions"]]}