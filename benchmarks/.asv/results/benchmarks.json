{
    "kernels.ArcCosine.time_covfunc_call": {
        "code": "class ArcCosine:\n    def time_covfunc_call(self, n_datapoints, n_dims):\n        self.kernel.gram(self.X)\n\n    def setup(self, n_datapoints, n_dims):\n        super().setup(n_datapoints, n_dims)\n        self.kernel = kernels.ArcCosine(active_dims=list(range(n_dims)))",
        "min_run_count": 2,
        "name": "kernels.ArcCosine.time_covfunc_call",
        "number": 0,
        "param_names": [
            "n_data",
            "dimensionality"
        ],
        "params": [
            [
                "10",
                "100",
                "500",
                "1000",
                "2000"
            ],
            [
                "1",
                "2",
                "5"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "f923a5feb1913469c66f702d89993918b418cc376b993df1cb7b974c3af01dfe",
        "warmup_time": -1
    },
    "kernels.Linear.time_covfunc_call": {
        "code": "class Linear:\n    def time_covfunc_call(self, n_datapoints, n_dims):\n        self.kernel.gram(self.X)\n\n    def setup(self, n_datapoints, n_dims):\n        super().setup(n_datapoints, n_dims)\n        self.kernel = kernels.Linear(active_dims=list(range(n_dims)))",
        "min_run_count": 2,
        "name": "kernels.Linear.time_covfunc_call",
        "number": 0,
        "param_names": [
            "n_data",
            "dimensionality"
        ],
        "params": [
            [
                "10",
                "100",
                "500",
                "1000",
                "2000"
            ],
            [
                "1",
                "2",
                "5"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "937688fe2a0aa44886c8c5856202502b9c82d2043d1034bf1c5984d73999b6b3",
        "warmup_time": -1
    },
    "kernels.Matern12.time_covfunc_call": {
        "code": "class Matern12:\n    def time_covfunc_call(self, n_datapoints, n_dims):\n        self.kernel.gram(self.X)\n\n    def setup(self, n_datapoints, n_dims):\n        super().setup(n_datapoints, n_dims)\n        self.kernel = kernels.Matern12(active_dims=list(range(n_dims)))",
        "min_run_count": 2,
        "name": "kernels.Matern12.time_covfunc_call",
        "number": 0,
        "param_names": [
            "n_data",
            "dimensionality"
        ],
        "params": [
            [
                "10",
                "100",
                "500",
                "1000",
                "2000"
            ],
            [
                "1",
                "2",
                "5"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "847a1c25403643211b2dbe93ac755ad2ddcd5da5e2b53136841d6ab99cc12699",
        "warmup_time": -1
    },
    "kernels.Matern32.time_covfunc_call": {
        "code": "class Matern32:\n    def time_covfunc_call(self, n_datapoints, n_dims):\n        self.kernel.gram(self.X)\n\n    def setup(self, n_datapoints, n_dims):\n        super().setup(n_datapoints, n_dims)\n        self.kernel = kernels.Matern32(active_dims=list(range(n_dims)))",
        "min_run_count": 2,
        "name": "kernels.Matern32.time_covfunc_call",
        "number": 0,
        "param_names": [
            "n_data",
            "dimensionality"
        ],
        "params": [
            [
                "10",
                "100",
                "500",
                "1000",
                "2000"
            ],
            [
                "1",
                "2",
                "5"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "a520e46707f3b3181f63c1e1a372e9e6cea4d8bcfc1d24ab4b7f40ff1dadf171",
        "warmup_time": -1
    },
    "kernels.Matern52.time_covfunc_call": {
        "code": "class Matern52:\n    def time_covfunc_call(self, n_datapoints, n_dims):\n        self.kernel.gram(self.X)\n\n    def setup(self, n_datapoints, n_dims):\n        super().setup(n_datapoints, n_dims)\n        self.kernel = kernels.Matern52(active_dims=list(range(n_dims)))",
        "min_run_count": 2,
        "name": "kernels.Matern52.time_covfunc_call",
        "number": 0,
        "param_names": [
            "n_data",
            "dimensionality"
        ],
        "params": [
            [
                "10",
                "100",
                "500",
                "1000",
                "2000"
            ],
            [
                "1",
                "2",
                "5"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "179838852e999abcac68e90c141724342d0b4a25656f5ea7be6409ac9205b91f",
        "warmup_time": -1
    },
    "kernels.Polynomial.time_covfunc_call": {
        "code": "class Polynomial:\n    def time_covfunc_call(self, n_datapoints, n_dims):\n        self.kernel.gram(self.X)\n\n    def setup(self, n_datapoints, n_dims):\n        super().setup(n_datapoints, n_dims)\n        self.kernel = kernels.Polynomial(active_dims=list(range(n_dims)))",
        "min_run_count": 2,
        "name": "kernels.Polynomial.time_covfunc_call",
        "number": 0,
        "param_names": [
            "n_data",
            "dimensionality"
        ],
        "params": [
            [
                "10",
                "100",
                "500",
                "1000",
                "2000"
            ],
            [
                "1",
                "2",
                "5"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "67213fe983f9f09d6213609250aab0870f9b652c1fb08e07f68581af193365d5",
        "warmup_time": -1
    },
    "kernels.PoweredExponential.time_covfunc_call": {
        "code": "class PoweredExponential:\n    def time_covfunc_call(self, n_datapoints, n_dims):\n        self.kernel.gram(self.X)\n\n    def setup(self, n_datapoints, n_dims):\n        super().setup(n_datapoints, n_dims)\n        self.kernel = kernels.PoweredExponential(active_dims=list(range(n_dims)))",
        "min_run_count": 2,
        "name": "kernels.PoweredExponential.time_covfunc_call",
        "number": 0,
        "param_names": [
            "n_data",
            "dimensionality"
        ],
        "params": [
            [
                "10",
                "100",
                "500",
                "1000",
                "2000"
            ],
            [
                "1",
                "2",
                "5"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "2da6e3291d5e431eed969aaba40c4b42f226ebad022e3ea56b257ab2e2e97bb4",
        "warmup_time": -1
    },
    "kernels.RBF.time_covfunc_call": {
        "code": "class RBF:\n    def time_covfunc_call(self, n_datapoints, n_dims):\n        self.kernel.gram(self.X)\n\n    def setup(self, n_datapoints, n_dims):\n        super().setup(n_datapoints, n_dims)\n        self.kernel = kernels.RBF(active_dims=list(range(n_dims)))",
        "min_run_count": 2,
        "name": "kernels.RBF.time_covfunc_call",
        "number": 0,
        "param_names": [
            "n_data",
            "dimensionality"
        ],
        "params": [
            [
                "10",
                "100",
                "500",
                "1000",
                "2000"
            ],
            [
                "1",
                "2",
                "5"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "b52f5ad2fdad31ce7060e8eb015e77504de6b2566db3b05e702d48e17f7c3e7f",
        "warmup_time": -1
    },
    "kernels.RationalQuadratic.time_covfunc_call": {
        "code": "class RationalQuadratic:\n    def time_covfunc_call(self, n_datapoints, n_dims):\n        self.kernel.gram(self.X)\n\n    def setup(self, n_datapoints, n_dims):\n        super().setup(n_datapoints, n_dims)\n        self.kernel = kernels.RationalQuadratic(active_dims=list(range(n_dims)))",
        "min_run_count": 2,
        "name": "kernels.RationalQuadratic.time_covfunc_call",
        "number": 0,
        "param_names": [
            "n_data",
            "dimensionality"
        ],
        "params": [
            [
                "10",
                "100",
                "500",
                "1000",
                "2000"
            ],
            [
                "1",
                "2",
                "5"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "4ff62cadc9b2f84aa5f6ea06736910da029bd98f3f7191de57356b43d6915b42",
        "warmup_time": -1
    },
    "linops.LinOps.time_inverse": {
        "code": "class LinOps:\n    def time_inverse(self, n_datapoints):\n        self.linop.inverse()\n\n    def setup(self, n_datapoints):\n        key = jr.PRNGKey(123)\n        self.X = jnp.asarray(make_spd_matrix(n_dim=n_datapoints, random_state=123))\n        self.y = jr.normal(key=key, shape=(n_datapoints, 1))\n        self.linop = DenseLinearOperator(matrix=self.X)",
        "min_run_count": 2,
        "name": "linops.LinOps.time_inverse",
        "number": 0,
        "param_names": [
            "n_data"
        ],
        "params": [
            [
                "10",
                "100",
                "200",
                "500",
                "1000"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "823cf69fc1b04db01ca405df4e4ad858be5f2f961474f37024055ee6b184b59d",
        "warmup_time": -1
    },
    "linops.LinOps.time_logdet": {
        "code": "class LinOps:\n    def time_logdet(self, n_datapoints):\n        self.linop.log_det()\n\n    def setup(self, n_datapoints):\n        key = jr.PRNGKey(123)\n        self.X = jnp.asarray(make_spd_matrix(n_dim=n_datapoints, random_state=123))\n        self.y = jr.normal(key=key, shape=(n_datapoints, 1))\n        self.linop = DenseLinearOperator(matrix=self.X)",
        "min_run_count": 2,
        "name": "linops.LinOps.time_logdet",
        "number": 0,
        "param_names": [
            "n_data"
        ],
        "params": [
            [
                "10",
                "100",
                "200",
                "500",
                "1000"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "639dad2164ac90fc52cdc42feb86a3a123ad523816883172d84302c4b5b0cdb9",
        "warmup_time": -1
    },
    "linops.LinOps.time_root": {
        "code": "class LinOps:\n    def time_root(self, n_datapoints):\n        self.linop.to_root()\n\n    def setup(self, n_datapoints):\n        key = jr.PRNGKey(123)\n        self.X = jnp.asarray(make_spd_matrix(n_dim=n_datapoints, random_state=123))\n        self.y = jr.normal(key=key, shape=(n_datapoints, 1))\n        self.linop = DenseLinearOperator(matrix=self.X)",
        "min_run_count": 2,
        "name": "linops.LinOps.time_root",
        "number": 0,
        "param_names": [
            "n_data"
        ],
        "params": [
            [
                "10",
                "100",
                "200",
                "500",
                "1000"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "cae06127f9dd4abd0e43b5d56de47907b15a7914dec0001a3dc0bf8e6ede3443",
        "warmup_time": -1
    },
    "linops.LinOps.time_solve": {
        "code": "class LinOps:\n    def time_solve(self, n_datapoints):\n        self.linop.solve(self.y)\n\n    def setup(self, n_datapoints):\n        key = jr.PRNGKey(123)\n        self.X = jnp.asarray(make_spd_matrix(n_dim=n_datapoints, random_state=123))\n        self.y = jr.normal(key=key, shape=(n_datapoints, 1))\n        self.linop = DenseLinearOperator(matrix=self.X)",
        "min_run_count": 2,
        "name": "linops.LinOps.time_solve",
        "number": 0,
        "param_names": [
            "n_data"
        ],
        "params": [
            [
                "10",
                "100",
                "200",
                "500",
                "1000"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "ae85c8782ac7af301f71850798f51a6e935da6685811c777f97ab715bbdb0ebc",
        "warmup_time": -1
    },
    "objectives.Bernoulli.time_eval": {
        "code": "class Bernoulli:\n    def time_eval(self, n_datapoints, n_dims):\n        self.objective.step(self.posterior, self.data).block_until_ready()\n\n    def setup(self, n_datapoints, n_dims):\n        key = jr.PRNGKey(123)\n        self.X = jr.normal(key=key, shape=(n_datapoints, n_dims))\n        self.y = jnp.where(jnp.sin(self.X[:, :1]) > 0, 1, 0)\n        self.data = gpx.Dataset(X=self.X, y=self.y)\n        kernel = gpx.kernels.RBF(active_dims=list(range(n_dims)))\n        meanf = gpx.mean_functions.Constant()\n        self.prior = gpx.Prior(kernel=kernel, mean_function=meanf)\n        self.likelihood = gpx.likelihoods.Bernoulli(num_datapoints=self.data.n)\n        self.objective = gpx.LogPosteriorDensity()\n        self.posterior = self.prior * self.likelihood",
        "min_run_count": 2,
        "name": "objectives.Bernoulli.time_eval",
        "number": 0,
        "param_names": [
            "n_data",
            "n_dims"
        ],
        "params": [
            [
                "10",
                "100",
                "200",
                "500",
                "1000"
            ],
            [
                "1",
                "2",
                "5"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "fb5ee5905aa83614349ecf957e77246930a4577b1b4308bb1fd4961104de464f",
        "warmup_time": -1
    },
    "objectives.Bernoulli.time_grad": {
        "code": "class Bernoulli:\n    def time_grad(self, n_datapoints, n_dims):\n        jax.block_until_ready(jax.grad(self.objective.step)(self.posterior, self.data))\n\n    def setup(self, n_datapoints, n_dims):\n        key = jr.PRNGKey(123)\n        self.X = jr.normal(key=key, shape=(n_datapoints, n_dims))\n        self.y = jnp.where(jnp.sin(self.X[:, :1]) > 0, 1, 0)\n        self.data = gpx.Dataset(X=self.X, y=self.y)\n        kernel = gpx.kernels.RBF(active_dims=list(range(n_dims)))\n        meanf = gpx.mean_functions.Constant()\n        self.prior = gpx.Prior(kernel=kernel, mean_function=meanf)\n        self.likelihood = gpx.likelihoods.Bernoulli(num_datapoints=self.data.n)\n        self.objective = gpx.LogPosteriorDensity()\n        self.posterior = self.prior * self.likelihood",
        "min_run_count": 2,
        "name": "objectives.Bernoulli.time_grad",
        "number": 0,
        "param_names": [
            "n_data",
            "n_dims"
        ],
        "params": [
            [
                "10",
                "100",
                "200",
                "500",
                "1000"
            ],
            [
                "1",
                "2",
                "5"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "38185efea870c669bb43effcdeb9736469e16211eb9bf1c385ef6e9e7016af9d",
        "warmup_time": -1
    },
    "objectives.Gaussian.time_eval": {
        "code": "class Gaussian:\n    def time_eval(self, n_datapoints, n_dims):\n        self.objective.step(self.posterior, self.data).block_until_ready()\n\n    def setup(self, n_datapoints, n_dims):\n        key = jr.PRNGKey(123)\n        self.X = jr.normal(key=key, shape=(n_datapoints, n_dims))\n        self.y = jnp.sin(self.X[:, :1])\n        self.data = gpx.Dataset(X=self.X, y=self.y)\n        kernel = gpx.kernels.RBF(active_dims=list(range(n_dims)))\n        meanf = gpx.mean_functions.Constant()\n        self.prior = gpx.Prior(kernel=kernel, mean_function=meanf)\n        self.likelihood = gpx.likelihoods.Gaussian(num_datapoints=self.data.n)\n        self.objective = gpx.ConjugateMLL()\n        self.posterior = self.prior * self.likelihood",
        "min_run_count": 2,
        "name": "objectives.Gaussian.time_eval",
        "number": 0,
        "param_names": [
            "n_data",
            "n_dims"
        ],
        "params": [
            [
                "10",
                "100",
                "200",
                "500",
                "1000"
            ],
            [
                "1",
                "2",
                "5"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "c95ff081d05fd04891867ccd92dd38fc091c1617f991faf7708322edd5763b26",
        "warmup_time": -1
    },
    "objectives.Gaussian.time_grad": {
        "code": "class Gaussian:\n    def time_grad(self, n_datapoints, n_dims):\n        jax.block_until_ready(jax.grad(self.objective.step)(self.posterior, self.data))\n\n    def setup(self, n_datapoints, n_dims):\n        key = jr.PRNGKey(123)\n        self.X = jr.normal(key=key, shape=(n_datapoints, n_dims))\n        self.y = jnp.sin(self.X[:, :1])\n        self.data = gpx.Dataset(X=self.X, y=self.y)\n        kernel = gpx.kernels.RBF(active_dims=list(range(n_dims)))\n        meanf = gpx.mean_functions.Constant()\n        self.prior = gpx.Prior(kernel=kernel, mean_function=meanf)\n        self.likelihood = gpx.likelihoods.Gaussian(num_datapoints=self.data.n)\n        self.objective = gpx.ConjugateMLL()\n        self.posterior = self.prior * self.likelihood",
        "min_run_count": 2,
        "name": "objectives.Gaussian.time_grad",
        "number": 0,
        "param_names": [
            "n_data",
            "n_dims"
        ],
        "params": [
            [
                "10",
                "100",
                "200",
                "500",
                "1000"
            ],
            [
                "1",
                "2",
                "5"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "17f8bbfec9594b825cce2619ff9cdff44460a0f3b9273276e132c466903cad5d",
        "warmup_time": -1
    },
    "objectives.Poisson.time_eval": {
        "code": "class Poisson:\n    def time_eval(self, n_datapoints, n_dims):\n        self.objective.step(self.posterior, self.data).block_until_ready()\n\n    def setup(self, n_datapoints, n_dims):\n        key = jr.PRNGKey(123)\n        self.X = jr.normal(key=key, shape=(n_datapoints, n_dims))\n        f = lambda x: 2.0 * jnp.sin(3 * x) + 0.5 * x  # latent function\n        self.y = jr.poisson(key, jnp.exp(f(self.X)))\n        self.data = gpx.Dataset(X=self.X, y=self.y)\n        kernel = gpx.kernels.RBF(active_dims=list(range(n_dims)))\n        meanf = gpx.mean_functions.Constant()\n        self.prior = gpx.Prior(kernel=kernel, mean_function=meanf)\n        self.likelihood = gpx.likelihoods.Poisson(num_datapoints=self.data.n)\n        self.objective = gpx.LogPosteriorDensity()\n        self.posterior = self.prior * self.likelihood",
        "min_run_count": 2,
        "name": "objectives.Poisson.time_eval",
        "number": 0,
        "param_names": [
            "n_data",
            "n_dims"
        ],
        "params": [
            [
                "10",
                "100",
                "200",
                "500",
                "1000"
            ],
            [
                "1",
                "2",
                "5"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "c6980ed01dfd22897a43064bc3210aa38052a9a542e380652f67e7a93e575ce6",
        "warmup_time": -1
    },
    "objectives.Poisson.time_grad": {
        "code": "class Poisson:\n    def time_grad(self, n_datapoints, n_dims):\n        jax.block_until_ready(jax.grad(self.objective.step)(self.posterior, self.data))\n\n    def setup(self, n_datapoints, n_dims):\n        key = jr.PRNGKey(123)\n        self.X = jr.normal(key=key, shape=(n_datapoints, n_dims))\n        f = lambda x: 2.0 * jnp.sin(3 * x) + 0.5 * x  # latent function\n        self.y = jr.poisson(key, jnp.exp(f(self.X)))\n        self.data = gpx.Dataset(X=self.X, y=self.y)\n        kernel = gpx.kernels.RBF(active_dims=list(range(n_dims)))\n        meanf = gpx.mean_functions.Constant()\n        self.prior = gpx.Prior(kernel=kernel, mean_function=meanf)\n        self.likelihood = gpx.likelihoods.Poisson(num_datapoints=self.data.n)\n        self.objective = gpx.LogPosteriorDensity()\n        self.posterior = self.prior * self.likelihood",
        "min_run_count": 2,
        "name": "objectives.Poisson.time_grad",
        "number": 0,
        "param_names": [
            "n_data",
            "n_dims"
        ],
        "params": [
            [
                "10",
                "100",
                "200",
                "500",
                "1000"
            ],
            [
                "1",
                "2",
                "5"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "9da29fc2c40db47e799a629b998835c42f1188786ec4cb956931def49fe94db7",
        "warmup_time": -1
    },
    "predictions.Bernoulli.time_predict": {
        "code": "class Bernoulli:\n    def time_predict(self, n_test, n_dims):\n        self.posterior.predict(test_inputs=self.xtest, train_data=self.data)\n\n    def setup(self, n_test, n_dims):\n        key = jr.PRNGKey(123)\n        self.X = jr.normal(key=key, shape=(100, n_dims))\n        self.y = jnp.sin(self.X[:, :1])\n        self.y = jnp.where(self.y > 0, 1, 0)\n        self.data = gpx.Dataset(X=self.X, y=self.y)\n        kernel = gpx.kernels.RBF(active_dims=list(range(n_dims)))\n        meanf = gpx.mean_functions.Constant()\n        self.prior = gpx.Prior(kernel=kernel, mean_function=meanf)\n        self.likelihood = gpx.likelihoods.Bernoulli(num_datapoints=self.data.n)\n        self.posterior: ConjugatePosterior = self.prior * self.likelihood\n        key, subkey = jr.split(key)\n        self.xtest = jr.normal(key=subkey, shape=(n_test, n_dims))",
        "min_run_count": 2,
        "name": "predictions.Bernoulli.time_predict",
        "number": 0,
        "param_names": [
            "n_test",
            "n_dims"
        ],
        "params": [
            [
                "100",
                "200",
                "500",
                "1000",
                "2000",
                "3000"
            ],
            [
                "1",
                "2",
                "5"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "857bb8965761478deabc31a9c7d8c448e15b04040ad3000f3215ecfc25b6572a",
        "warmup_time": -1
    },
    "predictions.Gaussian.time_predict": {
        "code": "class Gaussian:\n    def time_predict(self, n_test, n_dims):\n        self.posterior.predict(test_inputs=self.xtest, train_data=self.data)\n\n    def setup(self, n_test, n_dims):\n        key = jr.PRNGKey(123)\n        self.X = jr.normal(key=key, shape=(100, n_dims))\n        self.y = jnp.sin(self.X[:, :1])\n        self.data = gpx.Dataset(X=self.X, y=self.y)\n        kernel = gpx.kernels.RBF(active_dims=list(range(n_dims)))\n        meanf = gpx.mean_functions.Constant()\n        self.prior = gpx.Prior(kernel=kernel, mean_function=meanf)\n        self.likelihood = gpx.likelihoods.Gaussian(num_datapoints=self.data.n)\n        self.posterior: ConjugatePosterior = self.prior * self.likelihood\n        key, subkey = jr.split(key)\n        self.xtest = jr.normal(key=subkey, shape=(n_test, n_dims))",
        "min_run_count": 2,
        "name": "predictions.Gaussian.time_predict",
        "number": 0,
        "param_names": [
            "n_test",
            "n_dims"
        ],
        "params": [
            [
                "100",
                "200",
                "500",
                "1000",
                "2000",
                "3000"
            ],
            [
                "1",
                "2",
                "5"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "6f0e388859cf4b193a8b671902fd452e57ea9b7330f9a9226a3c683b9dd79fa1",
        "warmup_time": -1
    },
    "predictions.Poisson.time_predict": {
        "code": "class Poisson:\n    def time_predict(self, n_test, n_dims):\n        self.posterior.predict(test_inputs=self.xtest, train_data=self.data)\n\n    def setup(self, n_test, n_dims):\n        key = jr.PRNGKey(123)\n        self.X = jr.normal(key=key, shape=(100, n_dims))\n        f = lambda x: 2.0 * jnp.sin(3 * x) + 0.5 * x  # latent function\n        self.y = jr.poisson(key, jnp.exp(f(self.X)))\n        self.data = gpx.Dataset(X=self.X, y=self.y)\n        kernel = gpx.kernels.RBF(active_dims=list(range(n_dims)))\n        meanf = gpx.mean_functions.Constant()\n        self.prior = gpx.Prior(kernel=kernel, mean_function=meanf)\n        self.likelihood = gpx.likelihoods.Bernoulli(num_datapoints=self.data.n)\n        self.posterior: ConjugatePosterior = self.prior * self.likelihood\n        key, subkey = jr.split(key)\n        self.xtest = jr.normal(key=subkey, shape=(n_test, n_dims))",
        "min_run_count": 2,
        "name": "predictions.Poisson.time_predict",
        "number": 0,
        "param_names": [
            "n_test",
            "n_dims"
        ],
        "params": [
            [
                "100",
                "200",
                "500",
                "1000",
                "2000",
                "3000"
            ],
            [
                "1",
                "2",
                "5"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "e551f6f771a828ecf51e53287b7c46c8df0944cdba11bf2b731272bbad6d0128",
        "warmup_time": -1
    },
    "sparse.Sparse.time_eval": {
        "code": "class Sparse:\n    def time_eval(self, n_datapoints, n_dims):\n        self.objective(self.q, self.data)\n\n    def setup(self, n_datapoints, n_inducing):\n        key = jr.PRNGKey(123)\n        self.X = jr.normal(key=key, shape=(n_datapoints, 1))\n        self.y = jnp.sin(self.X[:, :1])\n        self.data = gpx.Dataset(X=self.X, y=self.y)\n        kernel = gpx.kernels.RBF(active_dims=list(range(1)))\n        meanf = gpx.mean_functions.Constant()\n        self.prior = gpx.Prior(kernel=kernel, mean_function=meanf)\n        self.likelihood = gpx.likelihoods.Gaussian(num_datapoints=self.data.n)\n        self.posterior = self.prior * self.likelihood\n    \n        Z = jnp.linspace(self.X.min(), self.X.max(), n_inducing).reshape(-1, 1)\n        self.q = gpx.CollapsedVariationalGaussian(\n            posterior=self.posterior, inducing_inputs=Z\n        )\n        self.objective = gpx.CollapsedELBO(negative=True)",
        "min_run_count": 2,
        "name": "sparse.Sparse.time_eval",
        "number": 0,
        "param_names": [
            "n_data",
            "n_inducing"
        ],
        "params": [
            [
                "2000",
                "5000",
                "10000",
                "20000"
            ],
            [
                "10",
                "20",
                "50",
                "100",
                "200"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "c42a0cef98e7ce98940fdd14075c567a03ab6e0217008f317c0b2ad4bc48bccb",
        "warmup_time": -1
    },
    "sparse.Sparse.time_grad": {
        "code": "class Sparse:\n    def time_grad(self, n_datapoints, n_dims):\n        jax.grad(self.objective)(self.q, self.data)\n\n    def setup(self, n_datapoints, n_inducing):\n        key = jr.PRNGKey(123)\n        self.X = jr.normal(key=key, shape=(n_datapoints, 1))\n        self.y = jnp.sin(self.X[:, :1])\n        self.data = gpx.Dataset(X=self.X, y=self.y)\n        kernel = gpx.kernels.RBF(active_dims=list(range(1)))\n        meanf = gpx.mean_functions.Constant()\n        self.prior = gpx.Prior(kernel=kernel, mean_function=meanf)\n        self.likelihood = gpx.likelihoods.Gaussian(num_datapoints=self.data.n)\n        self.posterior = self.prior * self.likelihood\n    \n        Z = jnp.linspace(self.X.min(), self.X.max(), n_inducing).reshape(-1, 1)\n        self.q = gpx.CollapsedVariationalGaussian(\n            posterior=self.posterior, inducing_inputs=Z\n        )\n        self.objective = gpx.CollapsedELBO(negative=True)",
        "min_run_count": 2,
        "name": "sparse.Sparse.time_grad",
        "number": 0,
        "param_names": [
            "n_data",
            "n_inducing"
        ],
        "params": [
            [
                "2000",
                "5000",
                "10000",
                "20000"
            ],
            [
                "10",
                "20",
                "50",
                "100",
                "200"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "5aaf0153a37ed3daf24fa0e2a128884fc50602f21a8cc268d5ddb989aaabcd66",
        "warmup_time": -1
    },
    "version": 2
}